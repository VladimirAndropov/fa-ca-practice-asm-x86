// Вызов my_malloc должен выделить память в куче, но хочется, чтобы это работало быстро, а системный вызов делать дорого.
// Поэтому будем хранить выделеные блоки памяти и пытаться их переиспользовать.
// Для этого у нас будет 2 функции: my_malloc просит блок памяти, my_free помечает блок, как свободный и дальше my_malloc
// сможет возвращать такие блоки. Считаем, что у нас есть heapstart и heapend (мы это умеем делать, см соседний файл)
// TODO: проход my_malloc по freelist и поиск свободных блоков без системного вызова + корректное извлечение ноды из freelist
//
// При вызове my_malloc будем просить на int больше памяти, чтобы туда сохранять размер блока, который мы просили.
// При этом возвращать будет адрес за size. Но мы будет знать, что левее указателя у нас хранится адрес. Показано ниже
// Структура памяти: [ program code ] [ program .data ] [ heap {size| .... } ] ... [ stack ]
my_malloc:
    push    %ebx
    
    mov     heapend, %ebx
    // Увеличиваем heapend на размер, который нас попросили выделить
    mov     8(%esp), %ecx
    add     %ecx, %ebx
    // Увеличиваем размер еще на 4, чтобы разерервировать место под size
    add     $4, %ebx
    
    // Сам вызов brk
    mov     $SYS_brk, %eax
    int     $0x80

    // Свопаем новый heapend и старый:
    // В eax лежит новый конец кучи
    //----
    // перекладываем старый конец кучи в ecx
    mov     heapend, %ecx
    // Новый конец кучи кладем в heapend
    mov     %eax, heapend
    // Старый конец кучи перекладываем в eax
    mov     %ecx, %eax
    //-----
    
    // Теперь нужно сохранить размер.
    // Старый конец кучи = новое начало кучи.
    // Поэтому будет считать от него
    // Сохраняем size: [size|......]
    // В ecx лежит размер памяти, которую нас просили выделить 
    mov     8(%esp), %ecx
    // Кладем этот размер памяти, которую выделили по адресу, который хранится в eax
    // То есть как раз в начало выделенного блока
    mov     %ecx, (%eax)
    // Сдвигаемся на 4, чтобы вернуть корректный адрес (пользователь не знает, что мы просили больше и
    // еще size сохоранили, поэтому для него должно быть проозрачно, что он получил адрес памяти того размера, который просил)
    add     $4, %eax

    pop     %ebx
    ret


    // [heap{size|.....} {size|.....}]
    //                         ^     ^ heapend

// После вызова my_free мы будем немного менять блок памяти, чтобы потом легко найти нужный, когда нас попросят сделать новый my_malloc
// Блок памяти у нас будет теперь так же хранить в "первой ячейке" размер блока, а сразу за ним адрес следующего свободного блока.
// После этого адреса будет что-то лежать, но нас это не волнует. В итоге получится односвязный список из областей памяти, по которому мы будем 
// проходить при вызове my_malloc и пытаться переиспользовать (not implemented).
// меняем память на { size|nextfree .................... }
my_free:
    // На вход ожидаем адрес, который мы вернули при вызове malloc
    // Поэтому знаем, что слева лежит размер блока
    mov     4(%esp), %ecx
    // смотрим на размер блока
    sub     $4, %ecx
    
    // Добавляем новую ноду в наш односвязный список из свободных блоков freelist
    // Будем обновлять начало, то есть наша новая нода будет указывать на старое начало листа
    mov     freelist, %edx
    // Сохраняем адрес начала freelist в нашу ноду в часть, которую мы обозначили nextfree
    mov     %edx, 4(%ecx)
    // Сохраняем адрес начала нашей области в freelist
    mov     %ecx, freelist
    ret

    .data
// Адрес начала кучи
heapstart:
    .int 0
// Адрес конца кучи
heapend:
    .int 0
// head листа с нодами из выделеных блоков памяти
freelist:
    .int 0
