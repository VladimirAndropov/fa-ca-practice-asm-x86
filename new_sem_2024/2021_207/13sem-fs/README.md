# 13 Семинар 01.03.2022 переменные окружения, exec

## Файлики с кодом:

* [Вывод переменных окружения](envp.c)
* [Использование getenv()](getenv.c)
* [плохие вещи с getenv()](getenv_test.c)
* [меняем переменную окружения с putenv](putenv.c)
* [меняем переменную окружения с setenv](setenv.c)
* [примеры функций из семейства exec...](exec.c)
* [exec + fork](exec_fork.c)
* [exec + fork + передача аргументов через командную строку](exec_fork_cmd.c)



## Переменные окружения
Переменные окружения существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). Посмотреть установленные переменные можно командой env (environment). 

При создании нового процесса (командой fork, например) копируется и переменные окружения.

## getenv()
Функция getenv() возвращает указатель на информацию об окружении, ассоциированную со строкой name в таблице информации окружения. 

Если функция вызвана с аргументом, который не соответствует никаким переменным окружения, то возвращается нулевой указатель.


# Меняем переменные окружения
## putenv()
```
putenv("HELLO=not world");
```
Меняет значение переменной окружения HELLO на not world.

При успешном завершении putenv возвращает 0, при ошибке -1.

## setenv()
```
status = setenv("HELLO2", "not world", 0);
```
первый параметр -  перемменная окружения

второй параметр - значение переменной окружения

третий параметр - флаг, отвечающий за перезапись значения. 

0 -> если перемменная окружения уже существует, то мы не меняем ее значения.

1 -> если перемменная окружения уже существует, то мы меняет ее значение.

Возращает значение 0 - если все ок, 1 - если не ок.

# Семейство функций exec...
Семейство функций  exec... загружает  и  запускает другие программы,   известные   как   "дочерние" процессы. 
Суффиксы l, v, p и e, добавляемые к имени семейства exec...   обозначают,   что  данная  функция  будет работать с некоторыми особенностями:
## execp()
вместо нас сам находит какой дочерний процесс открыть (под капотом в PATH ищет че куда), первым параметром передаем имя программы, дальше агрументы программы через запятую, заканчивающиеся NULL.
## execl()
Первым параметром передаем путь до бинаря программы, вторым - имя программы, третьим и далее - бесконечный массив из агрументов который мы хотим передать, NULL(шоб было понятно когда пора заканчивать и уже запускать программу).

## execv{p}()
Первым параметром передаем имя программы(если execvp) или путь до бинаря программы, (если execv), а вторым уже массив передаваемых аргументов, который заканчивается NULL.

## execle()
Первым параметром - путь до бинаря, вторым - много аргументов, заканчивающиеся NuLL, последним - массив с паеременными окружения, тоже заканчивается массив NULL.

Каждая функция семейства exec...  должна иметь один из двух суффиксов,  определяющих аргументы (либо l, либо  v).  Суффиксы  определения  маршрута  доступа (PATH) и унаследования операционной среды (p  и  e) являются необязательными.

Если процесс завершился успешно, то функция не возвращает ничего, если же случилась ошибка, то возвращает -1 и в errno передает ошибки. В любом случае по красоте можно отлавливать ошибки так:

```
int status = execl("/usr/bin/echo", "echo", "hello world", NULL);
perror("exec");
exit(1);
```
Тогда дальше в код не пойдет программа, а выйдет с ошибкой. Если же все закончилось хорошо, то perror и exit проигнорятся.


Так же можно через exec... запускать и скрипты. Например, вот так выглядит запуск скрипта с командной строки:

```
chmod +x skript.py
python3 skript.py  
   /*or*/
/*PATH_TO_python3*/ skript.py 
```

