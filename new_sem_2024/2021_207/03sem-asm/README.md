# 3 Семинар 16.11.2021 ASM 3

## Файлики с кодом
* [lea vs mov](lea.S)
* [Арифметика с lea](lea_operations.S)
* [Системный вызов exit](syscall.S)
* [Hello world системный вызов read](hello_world.S)
* [Hello user системные вызовы read/write](syscall_read.S)
* [Считать строку, прибавить 5 к каждому числу](add.S)
* [Работа с локальными переменными (стек)](local_vars.S)


## Сделать системный вызов

* Посмотреть на параметры, которые вызов принимает в мануале: `man 2 <name>`, например, `man 2 read`

  Положить в `%eax` номер системного вызова, можно посмотреть номера в `/usr/include/x86_64-linux-gnu/asm/unistd_32.h`, чтобы использовать номер можно объявить константу: `.equ SYS_write, 4`.

  Но лучше подключить `#include <sys/syscall.h>` и использовать аналогичную константу оттуда. Посмотреть можно тут: `/usr/include/x86_64-linux-gnu/bits/syscall.h`.

* Положить в `%ebx, %ecx, %edx` значения в том же поорядке, как в сигнатуре нужной функции.

  Например, для `read`  с сигнатурой `ssize_t read(int fd, void *buf, size_t count);` нужно в `%eax` положить 4, в `%ebx` файловый дескриптор, в `%ecx` адрес, куда можно сделать чтение и в `%edx` число, сколько нужно считать. Вернется количество реально считанных байт (по этому можно отлавливать, что ввод закончился).

    ```
    mov     $SYS_read, %eax
    mov     $STDIN_FILENO, %ebx
    mov     8(%ebp), %ecx
    mov     12(%ebp), %edx
    ```

    Файловые дескрипторы для stdin, stdout, stderr:

    ```
      STDIN_FILENO = 0
      STDOUT_FILENO = 1
      STDERR_FILENO = 2
    ```

* Сделать прерывание командой `int $0x80`. После этого будет осуществлен системный вызов.

----------
Программа должна завершаться системным вызовом `exit`.

Аргументом `exit` принимает код завершения программы. По соглашению 0 - если программа заверршается корректно, другое число, если произошла ошибка.

Посмотреть код завершения можно после выполнения любой программы: нашего бинаря, cat, man, ls...

`echo $?` - посмотреть код завершения последней выполненной программы. Обратите внимание, что там будет код завершения последней программы.

## Посмотреть, как работают stdout/stderr

Для примера можно посмотреть программу [Hello world](hello_world.S), она печатает что-то в stderr и stdout. Обычно в stderr выводятся ошибки или логи в stdout обычные выходные данные программы.

Пусть имя бинарного файла `hello_world`.

* `./hello_world` - если просто запустить, то вывод будет:
```
    hello from stdout
    hello from stderr
```

* `./hello_world 1> /dev/null` - можно перенаправить какой-то из потоков вывода в `/dev/null`, то есть удалить его и не выводить. Перенаправим 1 то есть `stdout` в `/dev/null`. Вывод будет:

```
  hello from stderr
```

* `./hello_world 1> stdout_file 2> stderr_file` - перенаправим выводы в разные файлы. stderr запишется в файл stderr_file, stdout в stdout_file.

* `./hello_world &> out_file` - перенаправить все. Все запишется в out_file.

* `./hello_world 2>&1` - перенаправить stderr в stdout.
* `./hello_world 1>out 2>&1` - перенаправить stderr в stdout и затем stdout в файл. Порядок перенаправлений важен!

Подоробнее можно посмотреть [тут](https://catonmat.net/bash-one-liners-explained-part-three).

## Lea

lea offset(base, index, mult), reg -> offset + base + index * mult -> reg

mult может быть только 2 4 8 16 для 32 битной системы.

[Пример использования lea](lea.S)

`lea` в отличие от `mov` не будет пытаться взять значение по получившемуся адресу, поэтому нет требования, чтобы адрес в итоге получится корректным. Поэтому его можно использовать для арифметических операций.

Например, если в `%ecx` лежит 5, а в `%edx` 6, то в результате работы следующего кода в `%eax` будет лежать `4 + (5 + 6 * 2)`
```
  lea     4(%ecx, %edx, 2), %eax
```

Если несколько операций сложения/умножения можно заменить одной операцией lea, то лучше так делать, потому что lea не сохраняет промежуточные результаты в регистры. Но lea не выставляет флаги.

[Использование lea для арифметических операций](lea_operations.S)
