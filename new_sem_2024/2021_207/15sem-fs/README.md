# 15 Семинар 15.03.2022 сигналы/sigaction

## Файлики с кодом:

* [бесконечный цикл, на котором учимся кидать убийственно крутые сигналы](yess.c)
* [sigaction](sigaction.c)
* [гонки](signal_race.c)
* [SIGINT с третьего раза и крутые атомарные переменные](atomic.c)
* [откладываем сигналы](block_sigint.c)

#  сигналы

Сигнал – это уведомление, отосланное процессу или определённому потоку процесса для того, чтобы сообщить ему о каком-то событии.
ниже примеры сигналов, посланных из терминала во время работы программы. 

```
^C (или SIGINT) - прерывает программу, все гуд
kill (id) - (дефолтный аргумент SIGTERM)
kill -2 (id) - где 2 - аругмент, который мы посылаем
kill -SIGINT (id) - альтернативная запись [kill -2 (id)]
```


^Z  -  приостанавливает процесс, если отправить 
```
kill -SIGCONT (id) 
```
передав id приостановленное программы, то можно ее запустить с того, места и idшник будет тем же самым, где ее прервали.

главный сингал-killer -SIGKILL, если остальные сигналы можно перехватить и как-то проигнорировать, то SIGKILL - бескомпромиссно приходит к ядру и говорит завязывать. Без шансов!
```
kill -SIGKILL (id) 
```

^\ это тоже самое, что и -SIGQUIT - оставляет с собой coredump (ядро создаёт дамп памяти процесса, если он выполнил недопустимую операцию, и должен быть остановлен) и создается [core](core)


#  sigaction

Системный вызов sigaction используется для изменения действий процесса при получении соответствующего сигнала.

```
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

```
Параметр signum задает номер сигнала и может быть равен любому номеру, кроме SIGKILL и SIGSTOP (невозможно заблокировать сигналы SIGKILL или SIGSTOP).

Если параметр act не равен нулю, то новое действие, связянное с сигналом signum, устанавливается соответственно act.

Структура sigaction имеет следующий формат:
```
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
```

```
sa.sa_handler = handler;
```
handler - функция которая принимает в себя int и ничего не возвращает. handler будет вызываться, если приходит определенный сигнал (signum, переданный в sigaction), то есть заменяет действия сигнала исполнением функции handler. И как только послали нам сигнал signum, программа резко останавливается и начинается выполнение handler, после чего программа продолжает выполняться оттуда, где ее прервали.

так же вместо хэндрела можно подкладывать и дефолтные handlerы (их всего два SIG_IGN - игнорщик, SIG_DFL - дефолтный, то есть обратно возвращает на стандартное поведение сигнала)

```
sa.sa_handler = SIG_IGN;
sa.sa_handler = SIG_DFL;
sa.sa_flags = SA_RESTART;    // передаем флаг -> SA_RESTART (если сигнал поступил, во время какого-то 
                             // системного вызова, то после обработки сигнала системный вызов рестартонется)
```

