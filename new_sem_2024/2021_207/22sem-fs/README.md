# АКОС_конспект 22

# 22 Семинар 24.05.2022

## Файлики с кодом

[thread_attributes](thread_attributes.c)

[thread_local_2](thread_local_2.c)

[thread_local_access](thread_local_access.c)

[thread_max](thread_max.c)

[thread_recursion](thread_recursion.c)

[thread_sigmask](thread_sigmask.c)

[thread_dock_example](thread_dock_example.c)

## Thread_local

У потоков общая память, в отличие от `fork`, там мы делились какими-то объектами. С потоками же иначе. Мы хотим уметь сохранять объект внутри потока. Есть тип `thread_local` и тогда значение будет локальным для потока.

[thread_local_2](thread_local_2.c)

- Через атрибуты можно регулировать поведение потока
- Заметим, что адрес переменной разный во всех потоках
- Это делается, когда мы хотим создать глобальную переменную, но только для одного потока.

[thread_local_access](thread_local_access.c)

- Все созданные потоки равноправны
- Нет гарантий по тому, какой поток создастся первым
- Не все потоки могут успеть что-то сделать
- Вообще `sleep` для синхронизации потоков делать странно (а как делать нормально, узнаем далее)

## Атрибуты pthread_create

[thread_attributes](thread_attributes.c)

Когда создается новый поток, у него появляется стек какого-то фиксированного размера. При помощи атрибутов мы можем изменить размер этого стека. Атрибуты нужно создать, потом инициализировать. Размер стека **не** может быть меньше 16КБ, а если что можно доставать значение из конфига. А еще после каждого стека выделяется дополнительное место, куда ничего нельзя писать, этот параметр тоже конфигурируется. Нужно быть аккуратнее с тем, чтобы не залезать на чужой стек.

[thread_recursion](thread_recursion.c)

Можно попробовать запустить рекурсию, чтобы поймать то, что мы идем в чужую память. `_SC_THREAD_STACK_MIN` — минимальный размер стека в байтах.

- Обычный размер страницы — 4КБ (память после стека)

[thread_max](thread_max.c)

Создаем потоки и останавливаемся тогда, когда не можем создать больше. Мы не делаем join ⇒ не освобождается память и поэтому в какой-то моменt не получится создать новый поток из-за отсутствия памяти. Но можно задать атрибут `PTHREAD_CREATE_DETACHED` и это будет значит, что какой-то поток мы ждать не будем, пусть он чистится сам и его значение нам не важно, тогда, вау, потоков может быть бесконечно.

## Signals

[thread_sigmask](thread_sigmask.c)

Вспомним, что у каждого потока своя маска с сигналами и когда приходит сигнал, он отправляется в тот поток, который может его обработать. Это можно регулировать при помощи блокировки и разблокировки сигналов, но по дефолту этого не сделать. Так что сигнал отправляется в какой-то поток, но в какой именно, не ясно никому. Если несколько сигналов пришли подряд и мы не успели их обработать, то мы и не узнаем, что их несколько. С несколькими потоками же обработчик сигналов вызовется несколько раз из разных потоков. А еще маску сигналов как раньше не получится при нескольких потоках, для этого есть `pthread_sigmask`. 

[thread_dock_example](thread_dock_example.c)

Пример того, как можно избежать ковыряния с обработчиком сигналов. Мы взяли и сделали специальный поток, который всегда ждать обработки сигналов, то есть если какой-то сигнал пришел, то он зайдет только в него.
