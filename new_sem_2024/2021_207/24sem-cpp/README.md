# [24 Семинар 07.06.2022 Нити С++](https://disk.yandex.ru/d/DQ3GNJCgfr6Jzg/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%B0%20%D0%B8%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/07.06_%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%B0_%D0%B8_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B_%D0%A1%D0%B5%D0%BC%D0%B8%D0%BD%D0%B0%D1%80_%D0%A4%D0%B8%D0%BB%D0%B8%D1%82%D0%BE%D0%B2_%D0%91%D0%9F%D0%9C%D0%98_207_07%2006%202022_9-58-22_%2B00-00.mp4)
## Файлики с кодом:
* [Простой пример thread](simple_thread.cpp)
* [Пример передачи в поток несколько аргументов](simple_thread_multiple_args.cpp)
* [Пример передачи в поток функцию класса](thread_callables.cpp)
* [Пример работы mutex](mutex.cpp)
* [Пример работы futures](futures.cpp)
* [Обработка исключений](exceptions.cpp)
* [Пример вызова несколько потоков](vector_threads.cpp)

## Класс `std::thread`
* Класс `std::thread` объявлен в заголовочном файле `<thread>`.
* Конструктор класса принимает любое количество аргументов. Первый аргумент - функция, которую хотим вызвать. Остальные аргументы передаются в качестве аргументов вызова.
* Можно передать `std::ref`, чтобы избежать копирования.
* Обязательно потом вызвать `join`.
* Thread нельзя копировать.

## Класс `std::mutex`, `std::lock_guard`
* Mutex - защита совместно используемых различными нитями статических переменных. Он может быть заблокирован или разблокирован. 
В статусе блокировки нельзя его повторно заблокировать. Разблокировать мьютекс обязана та же нить, которая его заблокировала.
* `Mutex` объявлен в заголовочном файле `<mutex>`.
Самые популярные методы класса:
```C++
void .lock() // блокирует mutex
void .unlock() // разблокирует mutex
bool .try_lock() // блокирует mutex, если это возможно
```
* Mutex опасен, когда принудительно выходим из-за return или exception и не успеваем разблокировать mutex. 
* В стандартной библиотеке объявлен `std::lock_guard`, который разблокирует mutex вследствии удаления объекта `lock_guard`.

## Класс `std::future`
* [std::promise](https://en.cppreference.com/w/cpp/thread/promise) объявлен в заголовочном файле `<future>`.
* [std::future](https://en.cppreference.com/w/cpp/thread/future) объявлен в заголовочном файле `<future>`.
* `promise` и `future` нужны, чтобы получить возвращаемые значения функций. Они работают по аналогии с каналом. В `promise` пишем значения с помощью `.set_value(val)`, из `future` забираем с помощью `.get()`.
* Записать или получить значение можно только ОДИН раз. Повторный вызов приведет к выброса исключения.

## References
* [Прошлый год](https://github.com/blackav/hse-caos-2020/tree/master/23-stdthread)
* [Move-Семантика](https://github.com/blackav/hse-caos-2020/blob/master/23-stdthread/cxx11_move.md)
