# Сервис запуска программы и замера времени

---

Проект свободен: нет

Участники: Дима Немов

Предложен студентами: нет

Ссылка на репозиторий: https://github.com/deymon-d/Time_measure

---

Пользователь пишет программу, компилирует ее, в файлах задает тестовые данные (один файл или несколько в папке, причем может быть вложенная структура). После этого иногда интересно, сколько займет времени выполнение программы, но железо самого пользователя может быть не мощным и старым, программа может долго выполняться, или писать каждый раз простой скрипт не очень хочется. Поэтому в этом задании предлагается написать сервер который выполняет эту работу за нас.

## Клиент

Бинарь + входные данных сохраняются в одну папку. После чего открывается клиент и скармливается в любом виде путь до этой папки и возможно дополнительные параметры. В любом виде означает:
1. клиенту передается это как аргументы строки, он выполняется всю работу, возвращает результат и завершается (меньше баллов, но с этого можно начинать).
2. или же он принимает аргументы через строку и в отдельном потоке выполняет всю работу, затем дожидается ответа, и в основном потоке выводит результат (+ сохранение в файл в той же папке). В этом время основной поток может принимать другие запросы. Данные можно хранить в любом виде (список, динамический массив).

Пользователь мог случайно удалить папку с бинарем, в этом случае нужно создать полный путь и сохранить в нее только результат.

Пользователь может несколько раз просить обработать одну и ту же папку. В этом случае надо проверить, что поменялось. Если ничего не поменялось, то не предпринимать других действий, если есть посчитанный результат то сразу выписать ответ. Если обновились только входные данные, то передать только их на сервер. Если обновился бинарь, то передать бинарь на сервер. В этих ситуациях работа сервера будет разной.

## Сервер

Сервер может делать соединение с несколькими клиентами. Клиент может передавать файлы в бинарном виде (структуры или формат кодирования опишите самостоятельно), может дать ссылку на файлы (например входные данные хранятся на гугл диске, а бинарь передается так), или текст программы с опциями компиляции (возможно ссылка на код программы, здесь можно подразумевать что файл один). В любом случае нужно на сервере получить бинарь и входные данные, и сообщить об успехе/ошибках пользователю.

Если пришел новый пользователь, а количество исполняемых уже забито, то можно сообщить клиенту о задержке. Также можно оценить для каждого исполняемого клиента время до завершения (если уже есть результаты работы для каких-то входов + eps времени на ответ и другую синхронизацию). Если же клиентов в очереди на исполнение и исполняемых слишком много, то ответить пользователю, что сервер нагружен.

Обработка клиента = отдельных процесс с 2+ потоками. Основном поток общается через канал c основным потоком сервера, чтобы например узнать, сколько времени осталось выполняться или передать новые данные.

### Обработка одного клиента

Нужно запустить бинарь на каждом тестовом входе и замерить время выполнения до ответа. Ожидание можно сделать активным, потому что мы хотим время довольно точно мерить.

Чтобы оценка была точнее, можно запустить для каждого входа несколько раз, и собрать статистику (0-50-90-95-100 процентили). Это передается как аргумент при запросе клиента (если нет, то по умолчанию делаем только один запуск).

Сервер имеет некоторое суммарное количество потоков, которые он может создавать (например обычно это число ограничено числом ядер). Процессу, который будет обрабатывать клиента, передается количество параллельных запусков, которые он может делать. Сам процесс плодит потоки, которые обрабатывают один запуск. Причем основной процесс сервера может изменять число параллельных запусков для клиента, как уменьшить, так и увеличить. А точнее, если нет новых клиентов некоторое время, то "свободные потоки" можно давать самым старым клиентам. А если число клиентов растет, а "свободных потоков" нет, то можно отбирать их у активных.

При планировании запусков для клиента, лучше сначала выполнить каждый вход по одному разу, а затем в произвольном порядке остальные запуски. В этом случае можно будет давать какую-то начальную оценку на оставшееся время.

Причем должен быть также поставлен таймаут на выполнение программы (может также передаться пользователем, по умолчанию 1 минута). Если таймаут сработал, то не учитывать в статистике, но клиенту нужно передать сколько их произошло. При срабатывании таймаута - убить процесс. Но при этом просто продолжить работу как если бы таймаута не было (возможно в ней был рандомизированный алгоритм поэтому сильно зависит от запуска).

Так как взаимодействие между клиентом и пользователем содержит много данный для разных целей (бинарник, входные данные, таймаут, статистики, ссылки), то должны быть созданы структуры, которые сериализуются в последовательность байт и расшифровывались из нее.

Если пользователь отправил новые входные данные (в любом виде что было описано раньше), то можно удалить еще не выполнившиеся старые входные, а статистику по выполнившимся оставить, и запускать уже на новых.

Если пользователь отправил новый бинарь (в любом виде), то отправить текущую статистику сразу в ответе, а затем все останавливать, и планировать как нового пользователя (то есть может так случится что придется подождать).

Любые данные (статистика для клиента или другая вспомогательная информация) должна удаляться через некоторое время, но удаляться.

Клиент может отправить запрос на отмену своего запроса. Для этого нужно сохраняться текущий прогресс, все файлы, и если через таймаут пользователь не попросит восстановить процесс, то удалить все данные.

Пользователь может попросить сохранить текущий его прогресс и данные (входные файлы + бинарь).

Пользователь может попросить восстановить предыдущий прогресс - останавливайте все, и загружайте сохранение из предыдущего абзаца. Конечно же, если сохранения не было, ничего не делайте.

Если клиент отключился, не завершайте работу сразу - ждите timeout. Если он подключится повторно то отправьте ему ответ, или продолжите работу, если она не завершилась.

## Что-то из высокого искусства

Один из принципов проектирования usability продукта - пользователь должен понимать, что происходит сейчас с его запросом, что может отменить его, и понимать что ему пишет сервер. Мы не будем проводить исследования, но если есть несколько вариантов что-то сделать, выбирайте тот, который по вашему ощущению как пользователя будет удобнее использовать. А это означает, что будет также проверять

- на любой запрос клиенту (с любым действием не только начальной отправкой) нужно написать ответ от сервера - получилось ли что-то сделать или ошибку
- пользователь может захотеть узнать прогресс - нужно ответить короткой информацией и текущей статистикой
- пользователь может отменить свой запрос
- пользователь может захотеть восстановить свой запрос
- пользователь может изменить данные своего запроса
- пользователь может делать что угодно со своей файловой системой, работа должна быть корректной
- пользователь может спросить, что вообще умеет делать сервер
- пользователь может спросить, что происходит в целом на сервере. Условно для того, что нужно ли будет ждать если он зальет новый бинарь

## Мониторинг сервера

При этом у сервера есть админ, которому нужно собирать статистики по временам выполнения программ, чтобы менять какие-то константы (все описанные таймауты), или добавлять премиум подписку на какие-то тяжелые запросы, если нагрузка на его сервис будет слишком большой (сейчас этого нет). Поэтому через сигналы от админа записываете процентили (50-90-95-100) по данным за последний день и час в отдельный файл. Админ также может остановить сервер через отправку сигнала (сервер должен сохранить все промежуточные данные), или убивать сервер (мгновенная смерть), восстанавливать его, а также перезагружать (просто чтобы была одной командой). Можете сделать отдельный модуль прямо для этой работы. Также у админа есть право стопорить любые процессы, поэтому он может еще запросить статистику по пользователям. Вам нужно будет самостоятельно написать инструкцию для админа (на какие сигналы что будет происходить).

# По вопросам что здесь происходит

Если хотите, спрашивайте в общей группе, уточнить написанное условие - @KseniaPetrenko.
