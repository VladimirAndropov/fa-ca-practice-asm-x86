# Посимвольное чтение из файла

Возможные варианты (см. детали реализации в [main.c](./main.c)):
* `read` - нет буферизации, системный вызов делается для каждого символа. Самый неэффективный способ чтения.
* `fscanf` - буферизованный ввод, но много накладных расходов. Как минимум, нужно распарсить форматную строку. Также, как и `scanf`, больше подходит для чтения форматированного текста (чисел/слов/...), чем для посимвольного чтения.
* `fgetc` - функция, специально предназнаяенная для посимвольного чтения. `getc` - почти то же самое, но может быть реализовано в виде макроса (в большинстве случаев разницы нет, [здесь](https://stackoverflow.com/a/18481102) можно почитать про возможные различия).
* `getc_unlocked` - нестандартная функция, для использования нужно определить макрос `_POSIX_C_SOURCE`.
  Работает в несколько раз быстрее, чем `getc`/`fgetc`, но **потоконебезопасна**, т.к. не использует внутреннюю блокировку.

### Сравнение методов

```bash
$ ./run.sh
Test 1M data
==========
READ
133851653

real	0m2.435s
user	0m0.343s
sys	0m2.089s
==========
FSCANF
133851653

real	0m0.056s
user	0m0.055s
sys	0m0.000s


Test 10M data
==========
FSCANF
1337475205

real	0m0.538s
user	0m0.516s
sys	0m0.020s
==========
FGETC
1337475205

real	0m0.084s
user	0m0.072s
sys	0m0.012s


Test 100M data
==========
FGETC
4278147277

real	0m0.258s
user	0m0.217s
sys	0m0.041s
==========
GETC
4278147277

real	0m0.268s
user	0m0.243s
sys	0m0.020s
==========
GETC_UNLOCKED
4278147277

real	0m0.068s
user	0m0.051s
sys	0m0.017s
```
